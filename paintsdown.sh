#!/usr/bin/env bash

set -eu
set -o pipefail
#set -x

trap cleanup EXIT

# auxiliary variables
deps=("pdftk" "convert" "img2pdf" "pdftoppm")
tempdir_suffix=".paintsdown"
tempdir_name=""
page_ranged_input_file=""

# command line arguments
input_file=""
output_file=""
force_output=0
color_to_use="magenta"
density="300"
verbose=0
keep_temp=0
first_page=""
last_page=""

cleanup() {
	local original_retval="$?"
	[ "$keep_temp" -eq 1 ] && return $original_retval
	[ -n "$tempdir_name" ] && rm -rf "$tempdir_name"
	return $original_retval
}

# creates tempdir and sets $tempdir_name variable. This variable will be used by the
# `cleanup` function to remove all the temp files at the end of execution
create_tempdir() {
	tempdir_name=$(mktemp -d --suffix="$tempdir_suffix")
	[ $? -eq 0 ] || error "Error creating temp directory"
}

# generates an empty channel file with the same dimensions as the input file. This way, we
# reuse empty channel files for pages with the same size in a given document
get_black_channel_file_for_page() {
	local channel_k_file="$1"
	local dimensions=$(identify -format "%w_%h" "$channel_k_file")
	local page_empty_channel_file="${tempdir_name}/empty_${dimensions}.png"
	if [ ! -e "$page_empty_channel_file" ]; then
		convert "$channel_k_file" -density "$density" \
			-evaluate set 0% -negate "$page_empty_channel_file"
	fi
	echo "$page_empty_channel_file"
}

create_cmy_pages() {
	local cyan="empty_channel_file"
	local yellow="empty_channel_file"
	local magenta="empty_channel_file"
	if [ "$color_to_use" == "cyan" ]; then
		cyan="black_channel"
	fi;
	if [ "$color_to_use" == "magenta" ]; then
		magenta="black_channel"
	fi;
	if [ "$color_to_use" == "red" ]; then
		magenta="black_channel"
		yellow="black_channel"
	fi;
	if [ "$color_to_use" == "green" ]; then
		cyan="black_channel"
		yellow="black_channel"
	fi;
	for black_channel in ${tempdir_name}/channel_k*.tiff; do
		local empty_channel_file=$(get_black_channel_file_for_page "$black_channel")
		local processed_page_file=${black_channel/channel_k/cmy}
		processed_page_file="${processed_page_file%.tiff}.png"
		convert "${!cyan}" \
			"${!magenta}" \
			"${!yellow}" \
			"$empty_channel_file" \
			-combine -colorspace CMYK "$processed_page_file"
	done;
}

# concat pages generated by `create_cmy_pages` into a new PDF document and place it in the
# working directory, alongside with the input document
concat_processed_pages() {
	local image_layer_output="$tempdir_name"/image-layer.output.pdf
	img2pdf `ls -1 "$tempdir_name"/cmy*.png | sort -V` \
		-o "$image_layer_output"
	pdftk "$page_ranged_input_file" multistamp "$image_layer_output" \
		output "$output_file"
}

display_success_message() {
	echo "display_success_message"
}

# display error message and die
error() {
	 >&2 echo "error: $1"
	exit 1
}

verbose() {
	[ "$verbose" -eq 1 ] && echo "$1"
}

# make sure dependencies are installed
validate_deps() {
	for dep in "${deps[@]}"; do
		set +e
		which "$dep" > /dev/null
		[ "$?" -ne 0 ] && error "dependency $dep was not found"
		set -e
	done;
}

print_usage() {
    cat <<'EOF'
Usage: paintsdown -i <filename> -o <filename> [OPTIONS]

Mandatory options:
  -i, --input <filename>
      Input file to be processed. Must be a valid filename.

  -o, --output <filename>
      Output file to generate. Must be a valid filename.

Optional options:
  -h, --help
      Show this help message and exit.

  -c, --color <magenta|cyan|red|green>
      Select the color to use. Must be one of:
      magenta, cyan, red, or green. Default is magenta

  -d, --density
      Sets document's density (resolution), in DPI. Default is 300

  -v, --verbose
      Enable verbose mode. Prints extra details during execution.

  -f, --force
      Overwrite the output file if it already exists.

  -k, --keep-temp
      Keep temporary files instead of deleting them after execution.

Examples:
  paintsdown -i source.txt -o result.txt -c magenta
  paintsdown --input data.md --output out.html --color cyan --verbose
  paintsdown -f -i in.md -o out.md -c red
EOF
}

# function `get_suffixed_filename`
# Arguments:
# $1: input file path
# $2: file name suffix
# $3 (optional): new extension
#
# Example:
# $1: /home/fool/input.pdf
# $2: "barl"
# Result: /home/fool/input.barl.pdf
get_suffixed_filename() {
	[ -z "$1" ] && error "get_suffixed_filename: no file name"
	[ -z "$2" ] && error "get_suffixed_filename: no suffix"
	local basename=$(basename "$1")
	local filename_noext="${basename%.*}"
	local dirname=$(dirname "$1")
	local extension="${basename##*.}"
	if [ -n "$3" ]; then
		extension="$3"
	fi;
	echo "${dirname}/${filename_noext}.""$2"".${extension}"
}

# create a temporary copy of the input file, limiting the range of its pages if necessary.
# This copy is necessary because the last step of the pipeline (a pdftk multistamp
# operation) doesn't allow us to select a page range -- therefore we must give it a
# pdf with the right number of pages for it to operate upon
create_page_ranged_input() {
	page_ranged_input_file="${tempdir_name}/page_ranged_input.pdf"
	local cat_first_page="1"
	local cat_last_page="end"
	if [ -n "$first_page" ]; then
		cat_first_page=${first_page}
	fi
	if [ -n "$last_page" ]; then
		cat_last_page=${last_page}
	fi
	if [[ -n "$first_page" || -n "$last_page" ]]; then
		pdftk "$input_file" cat ${cat_first_page}-${cat_last_page} \
			output "$page_ranged_input_file"
	else
		cp "$input_file" "$page_ranged_input_file"
	fi
}

# create a grayscale version and save it in the tempdir
create_gray_pages() {
	pdftoppm -gray -r "$density" -png "$page_ranged_input_file" \
		"${tempdir_name}/"gray
}

create_black_masks() {
	#convert cmyk.tiff -channel K -separate k.png
	for gray_page in ${tempdir_name}/gray-*.png; do
		convert "$gray_page" -channel K -separate "${gray_page/gray/channel_k}.tiff"
	done;
}

parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
			-h|--help)
				print_usage
				exit 0
				;;
			-v|--verbose)
				verbose=1
				shift
				;;
			-f|--force)
				force_output=1
				shift
				;;
			-k|--keep-temp)
				keep_temp=1
				shift
				;;
			-c|--color)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a color"
				fi
				case "$2" in
					magenta|cyan|red|green)
						color_to_use="$2"
						;;
					*)
						error "invalid color. Supported colors are 'magenta', 'cyan', 'red', and 'green' only"
						;;
				esac
				shift 2
				;;
			-d|--density)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a density value"
				fi
				density="$2"
				shift 2
				;;
			--first)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a page number"
				fi
				first_page="$2"
				shift 2
				;;
			--last)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a page number"
				fi
				last_page="$2"
				shift 2
				;;
			-i|--input)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a filename"
				fi
				input_file="$2"
				shift 2
				;;
			-o|--output)
				if [[ $# -lt 2 || "$2" =~ ^- ]]; then
					error "option $1 requires a filename"
				fi
				output_file="$2"
				shift 2
				;;
			*)
				error "Unknown parameter $1"
				exit 1
				;;
		esac
	done

	[ -z "$input_file" ] && error "input file not defined via option -i"
	[ -f "$input_file" ] || error "input file $input_file doesn't exist or isn't a regular file"
	[ -z "$output_file" ] && error "output file not defined via option -o"
	[ "$input_file" == "$output_file" ] && error "using the same file as both input and output is not recomended"
	[[ -f "$output_file" && "$force_output" -ne 1 ]] && error "output file $output_file already exists and --force is not specified"
	return 0
}

main() {
	parse_args "$@"
	validate_deps
	create_tempdir
	create_page_ranged_input
	create_gray_pages
	create_black_masks
	create_cmy_pages
	concat_processed_pages
	display_success_message
}

main "$@"
#parse_args "$@"
#get_suffixed_filename "/home/fool/input.pdf" "barl" "tiff"
#create_gray_pages "/tmp/input.pdf" "gray"
#create_tempdir
#convert /tmp/input.pdf "${tempdir_name}/"gray-%d.png


#!/usr/bin/env bash

set -eu
set -o pipefail
set -x

trap cleanup EXIT

tempdir_suffix=".paintsdown"
tempdir_name=""
input_file=""
keep_temp=1 #TODO make it configurable via command line parameter

cleanup() {
	echo "cleanup"
	[ "$keep_temp" -eq 1 ] && return
	[ -n "$tempdir_name" ] && rm -rf "$tempdir_name"
}

# creates tempdir and sets $tempdir_name variable. This variable will be used by the
# `cleanup` function to remove all the temp files at the end of execution
create_tempdir() {
	echo "create_tempdir"
	tempdir_name=$(mktemp -d --suffix="$tempdir_suffix")
	[ $? -eq 0 ] || error "Error creating temp directory"
}

create_cmy_pages() {
	# create a zeroed black mask
	local empty_black_file="${tempdir_name}/empty_black.png"
	convert $(ls "${tempdir_name}"/channel_k*.tiff | head -1) \
		-evaluate set 0% -negate "$empty_black_file"
	for black_channel in ${tempdir_name}/channel_k*.tiff; do
		local processed_page_file=${black_channel/channel_k/cmy}
		convert "$black_channel" \
			"$black_channel" \
			"$black_channel" \
			"$empty_black_file" \
			-combine -colorspace CMYK "$processed_page_file"
	done;
}

# concat pages generated by `create_cmy_pages` into a new PDF document and place it in the
# working directory, alongside with the input document
concat_processed_pages() {
	echo "concat_processed_pages"
}

display_success_message() {
	echo "display_success_message"
}

# display error message and die
error() {
	echo "$1" >&2
	exit 1
}

# make sure dependencies are installed
validate_deps() {
	# check pdftk, convert
	echo "validate_deps"
}

# function `get_suffixed_filename`
# Arguments:
# $1: input file path
# $2: file name suffix
# $3 (optional): new extension
#
# Example:
# $1: /home/fool/input.pdf
# $2: "barl"
# Result: /home/fool/input.barl.pdf
get_suffixed_filename() {
	[ -z "$1" ] && error "get_suffixed_filename: no file name"
	[ -z "$2" ] && error "get_suffixed_filename: no suffix"
	local basename=$(basename "$1")
	local filename_noext="${basename%.*}"
	local dirname=$(dirname "$1")
	local extension="${basename##*.}"
	if [ -n "$3" ]; then
		extension="$3"
	fi;
	echo "${dirname}/${filename_noext}.""$2"".${extension}"
}

# create a grayscale version and save it in the tempdir
create_gray_pages() {
	pdftoppm -gray -r 300 -png "$input_file" "${tempdir_name}/"gray
}

create_black_masks() {
	#convert cmyk.tiff -channel K -separate k.png
	for gray_page in ${tempdir_name}/gray-*.png; do
		convert "$gray_page" -channel K -separate "${gray_page/gray/channel_k}.tiff"
	done;
}

# apply OCR over the final document. HOWEVER, ideally, we should use the same information
# of the input document, instead of running an entire OCR pipeline over the processed
# document -- all of that only to obtain an information we already have in the original,
# input document!
apply_ocr() {
	echo "apply_ocr"
}

process_args() {
	[ -z "$1" ] && error "no input file"
	[ -r "$1" ] || error "input file $1 doesn't exist or isn't readable"
	input_file="$1"
}

main() {
	echo "arguments: $@"
	validate_deps
	process_args "$@"
	create_tempdir
	create_gray_pages
	create_black_masks
	create_cmy_pages
	concat_processed_pages
	apply_ocr #optional?
	display_success_message
}

main "$@"
#get_suffixed_filename "/home/fool/input.pdf" "barl" "tiff"
#create_gray_pages "/tmp/input.pdf" "gray"
#create_tempdir
#convert /tmp/input.pdf "${tempdir_name}/"gray-%d.png

